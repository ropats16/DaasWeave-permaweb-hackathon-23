import type { AsVerifier, Override, Null, ConnectionConstructor, PostMessageOptions } from './types';
import type Transaction from 'arweave/web/lib/transaction';
import type { TransactionInterface } from 'arweave/web/lib/transaction';
import type { ApiConfig } from 'arweave/web/lib/api';
interface SerializedTx extends Override<TransactionInterface, {
    tags: {
        name: string;
        value: string;
    }[];
    data: any;
}> {
}
declare type DecryptOptions = AlgorithmIdentifier | Override<RsaOaepParams, {
    label?: string;
}>;
declare type DispatchResult = {
    id?: string;
    type?: 'BASE' | 'BUNDLED';
};
export interface ArweaveInterface {
    getPublicKey(): Promise<string>;
    getArweaveConfig(): Promise<Omit<ApiConfig, 'logger'>>;
    signTransaction(tx: Transaction, options?: object | Null): Promise<Transaction>;
    dispatch(tx: Transaction, options?: object | Null): Promise<DispatchResult>;
    decrypt(message: ArrayBufferView, options: DecryptOptions): Promise<ArrayBufferView>;
}
export interface ArweaveProviderInterface extends Override<ArweaveInterface, {
    getArweaveConfig(): Promise<Override<ApiConfig, {
        logger?: any;
    }>>;
    signTransaction(tx: Partial<SerializedTx>, options?: object | Null): Promise<{
        id: string;
        owner?: string | Null;
        tags?: SerializedTx['tags'] | Null;
        signature: string;
        reward?: string | Null;
    }>;
    dispatch(tx: Partial<SerializedTx>, options?: object | Null): Promise<DispatchResult>;
}> {
}
export declare function ArweaveApi<TBase extends ConnectionConstructor>(Base: TBase): {
    new (...args: any[]): {
        namespaces: {
            arweaveWallet: {
                walletName: string;
                connect: () => any;
                disconnect: () => any;
                getActiveAddress: () => string | undefined;
                getActivePublicKey: () => Promise<string>;
                getAllAddresses: () => never;
                getWalletNames: () => never;
                sign: (tx: Transaction, options?: any) => Promise<Transaction>;
                dispatch: (tx: Transaction, options?: any) => Promise<DispatchResult>;
                encrypt: () => never;
                decrypt: (data: Uint8Array, options: any) => Promise<Uint8Array>;
                getPermissions: () => string[];
                getArweaveConfig: () => Promise<Omit<ApiConfig, "logger"> & {
                    logger?: any;
                }>;
            };
        };
        postMessage(method: string, params?: any[] | undefined, options?: PostMessageOptions | undefined): any;
        getPublicKey(): Promise<string>;
        getArweaveConfig(): Promise<Omit<ApiConfig, "logger"> & {
            logger?: any;
        }>;
        signTransaction(tx: Transaction, options?: object | Null): Promise<Transaction>;
        dispatch(tx: Transaction, options?: object | Null): Promise<DispatchResult>;
        decrypt<T extends ArrayBufferView>(message: T, options: DecryptOptions): Promise<T>;
        address?: string | undefined;
        connect(): any;
        disconnect(): any;
    };
} & TBase;
export declare class ArweaveVerifier implements AsVerifier<ArweaveProviderInterface> {
    getPublicKey(): boolean;
    getArweaveConfig(): boolean;
    signTransaction(tx: Partial<SerializedTx>, options?: object | Null): boolean;
    dispatch(tx: Partial<SerializedTx>, options?: object | Null): boolean;
    decrypt(message: ArrayBufferView, options: DecryptOptions): boolean;
}
export {};
