var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Bridge from './Bridge.js';
import Emitter from '../utils/Emitter.js';
import { generateUrl } from '../utils/Utils.js';
import { load, unload } from '../utils/Inject.js';
import { windowMissing } from '../utils/Errors.js';
import { is } from 'typescript-is';
// todo disable multiple instances
export default class BrowserConnector extends Emitter {
    constructor(appInfo, connectToUrl) {
        super();
        this._session = 0;
        this._listener = (message) => {
            const { method, params, session } = message;
            if (session != null && this._session != session) {
                return;
            }
            if (!session && this._session) {
                return;
            }
            if (method === 'connect') {
                if (!is(params, object => { function _string(object) { ; if (typeof object !== "string")
                    return {};
                else
                    return null; } return _string(object); })) {
                    return;
                }
                this.setAddress(params);
            }
            if (method === 'disconnect') {
                this.disconnectEvent(false);
            }
        };
        this._appInfo = appInfo;
        this._emitterPassthrough = (param) => {
            const event = Object.entries(param)[0];
            this.emit(event[0], event[1]);
        };
        this.on('connect', () => load(this));
        this.on('disconnect', () => unload(this));
        if (connectToUrl) {
            this.setUrl(connectToUrl);
        }
    }
    get address() { return this._address; }
    setAddress(value) {
        if (value && value === this.address) {
            return;
        }
        this._address = value;
        value != null ? this.emit('connect', value) : this.emit('disconnect', value);
        this.emit('change', value);
    }
    get connected() { return this._address != null; }
    get url() { var _a; return (_a = this._bridge) === null || _a === void 0 ? void 0 : _a.url; }
    get showIframe() { var _a; return ((_a = this._bridge) === null || _a === void 0 ? void 0 : _a.showIframe) || false; }
    get usePopup() { var _a; return ((_a = this._bridge) === null || _a === void 0 ? void 0 : _a.usePopup) || false; }
    get requirePopup() { var _a; return ((_a = this._bridge) === null || _a === void 0 ? void 0 : _a.requirePopup) || false; }
    get keepPopup() { var _a; return ((_a = this._bridge) === null || _a === void 0 ? void 0 : _a.keepPopup) || false; }
    set keepPopup(keep) { this._bridge && (this._bridge.keepPopup = keep); }
    setUrl(connectToUrl) {
        var _a;
        if (!window) {
            console.error(windowMissing);
            return;
        }
        const oldBridge = this._bridge;
        const url = generateUrl(connectToUrl);
        this._url = url;
        if (((_a = this._bridge) === null || _a === void 0 ? void 0 : _a.url) === url.origin) {
            return;
        }
        this.disconnect();
        if (!BrowserConnector._bridges[url.origin]) {
            this._bridge = new Bridge(url, this._appInfo);
            BrowserConnector._bridges[url.origin] = { bridge: this._bridge, sessions: [] };
        }
        else {
            this._bridge = BrowserConnector._bridges[url.origin].bridge;
            const sessions = BrowserConnector._bridges[url.origin].sessions;
            for (let i = 0; i <= sessions.length; i++) {
                if (sessions.indexOf(i) < 0) {
                    this._session = i;
                    break;
                }
            }
        }
        BrowserConnector._bridges[url.origin].sessions.push(this._session);
        this._bridge.on('message', this._listener);
        this._bridge.on('builtin', this._emitterPassthrough);
        if (this._bridge.showIframe !== (oldBridge === null || oldBridge === void 0 ? void 0 : oldBridge.showIframe)) {
            this.emit('showIframe', this._bridge.showIframe);
        }
        if (this._bridge.usePopup !== (oldBridge === null || oldBridge === void 0 ? void 0 : oldBridge.usePopup)) {
            this.emit('usePopup', this._bridge.usePopup);
        }
        if (this._bridge.requirePopup !== (oldBridge === null || oldBridge === void 0 ? void 0 : oldBridge.requirePopup)) {
            this.emit('requirePopup', this._bridge.requirePopup);
        }
        if (this._bridge.keepPopup !== (oldBridge === null || oldBridge === void 0 ? void 0 : oldBridge.keepPopup)) {
            this.emit('keepPopup', this._bridge.keepPopup);
        }
    }
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._bridge) {
                this._url && this.setUrl(this._url);
            }
            const promise = new Promise((resolve, reject) => {
                this.once('change', address => address ? resolve(address) : reject());
            }).finally(() => { var _a; return (_a = this._bridge) === null || _a === void 0 ? void 0 : _a.completeRequest(); });
            this._bridge.deliverMessage({ method: 'connect', params: options });
            return promise;
        });
    }
    disconnect(options) {
        return __awaiter(this, void 0, void 0, function* () { return this.disconnectEvent(true, options); });
    }
    disconnectEvent(fromMethod, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._bridge) {
                return;
            }
            const oldBridge = this._bridge;
            const session = this._session;
            const url = oldBridge.url;
            this.setAddress(undefined);
            this._bridge = undefined;
            this._session = 0;
            if (fromMethod) {
                // todo add timeout
                try {
                    yield oldBridge.postMessage({ method: 'disconnect', params: [options], session });
                }
                catch (e) {
                    console.warn('disconnect request failed');
                }
            }
            oldBridge.off('message', this._listener);
            oldBridge.off('builtin', this._emitterPassthrough);
            BrowserConnector._bridges[url].sessions = BrowserConnector._bridges[url].sessions.filter(x => x != session);
            setTimeout(() => {
                if (BrowserConnector._bridges[url].sessions.length) {
                    return;
                }
                BrowserConnector._bridges[url].bridge.destructor();
                delete BrowserConnector._bridges[url];
            }, 100);
        });
    }
    postMessage(method, params, options) {
        return new Promise((resolve, reject) => {
            if (!this._bridge) {
                return reject('URL missing');
            }
            this.once('disconnect', reject);
            this._bridge.postMessage({ method, params, session: this._session, protocol: options === null || options === void 0 ? void 0 : options.protocol, version: options === null || options === void 0 ? void 0 : options.version }, options).then(resolve).catch(reject);
        });
    }
}
BrowserConnector._bridges = {};
//# sourceMappingURL=Connector.js.map